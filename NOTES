This is all pretty mock up.

Right now there are two threads:

	A.) main thread that does input polling, rendering, etc.
	B.) game implementation.

Each thread goes about doing it's own business.

Action's bound to keys in the game thread (B) currently run in the main thread
(A). This is not desired.

	Option A.)
		Binding Actions tells InputManager/GameEngine to look for these
		events.  When they occur, push them into an event queue for
		game thread (B) to consume by executing the associated actions.

	Option B.)
		Move the input stuff into game thread (B).

Option B would probably be less code, simpler, and faster. It would also
complicate or break Android, which needs to run GUI in the main thread.

Option A would yield code of value. There will have to be a queue for the game
threads to communicate. I.e. Game thread (B) needs to update the position of an
entity and main thread (A) needs to render the movement.


The shutdown sequence is not quite kosher. When GameEngine.stop() gets called
it interupts the Game Thread (B) and wraps up. Instead it should likely
mGame.requestStop() and then wait for a notify[All]() in Game.stop().


LWJGL lets us use whatever OpenGL version is supported when the display is
created. Can't seem to get more details before hand. Joy. Code like this:

        ContextAttribs ca = new ContextAttribs(2, 0).withProfileES(true).withForwardCompatible(false);

Will create something we can use for Display.create(). The only thing is we
can't get a higher version and the ES profile, then whatever the associated
version is. So either we can have a steady ES profile for PC or rely on
whatever we find.


The input manager implementations should provide a way of getting the more
detailed text for an event. E.g. a way to get '`' or 'a' instead of only
'GRAVE' or 'A', respectively.

