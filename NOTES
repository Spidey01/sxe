This is all pretty mock up.

Right now there are two threads:

	A.) main thread that does input polling, rendering, etc.
	B.) game implementation.

Each thread goes about doing it's own business.

Action's bound to keys in the game thread (B) currently run in the main thread
(A). This is not desired.

	Option A.)
		Binding Actions tells InputManager/GameEngine to look for these
		events.  When they occur, push them into an event queue for
		game thread (B) to consume by executing the associated actions.

	Option B.)
		Move the input stuff into game thread (B).

Option B would probably be less code, simpler, and faster. It would also
complicate or break Android, which needs to run GUI in the main thread.

Option A would yield code of value. There will have to be a queue for the game
threads to communicate. I.e. Game thread (B) needs to update the position of an
entity and main thread (A) needs to render the movement.

LWJGL won't allow some operations from another thread (at least without sync). E.g. making a shader in SnakeGame blows up :/.

The shutdown sequence is not quite kosher. When GameEngine.stop() gets called
it interupts the Game Thread (B) and wraps up. Instead it should likely
mGame.requestStop() and then wait for a notify[All]() in Game.stop().


LWJGL lets us use whatever OpenGL version is supported when the display is
created. Can't seem to get more details before hand. Joy. Code like this:

        ContextAttribs ca = new ContextAttribs(2, 0).withProfileES(true).withForwardCompatible(false);

Will create something we can use for Display.create(). The only thing is we
can't get a higher version and the ES profile, then whatever the associated
version is. So either we can have a steady ES profile for PC or rely on
whatever we find.


The input manager implementations should provide a way of getting the more
detailed text for an event. E.g. a way to get '`' or 'a' instead of only
'GRAVE' or 'A', respectively.

this code was stuffed into PcDisplay for some testing stuff:
///////////////////////////////////////////////////////////////////////////////
// Testing stuff
///////////////////////////////////////////////////////////////////////////////

    private static OpenGl mGL = new LwjglOpenGl();

    private static IntBuffer m_geometryBuffer;
    private static IntBuffer m_colorBuffer;
    private static LwjglGlslProgram m_program;
    private static LwjglGlslShader m_vertShader;
    private static LwjglGlslShader m_fragShader;
    private static int m_positionLocation;
    private static int m_colorLocation;

    private void debuggy_init() { // place to test shit

        // 128,0,128 -> for my Firefly.
        GL11.glClearColor(0.5f, 0.0f, 0.5f, 1.0f);

        // mGL.glEnable(OpenGl.GL_CULL_FACE);
        // mGL.glEnable(OpenGl.GL_DEPTH_TEST);

        //---------------------------------------------------
        //create a triangle
        float[] geometryData = {
            -0.5f, -0.5f, 0.0f, 1.0f, //4 floats define one vertex (x, y, z and w), first one is lower left
            0.5f,  -0.5f, 0.0f, 1.0f, //we go counter clockwise, so lower right vertex next
            0.0f,  0.5f,  0.0f, 1.0f  //top vertex is last
        };
        FloatBuffer buffer = mGL.createFloatBuffer(geometryData.length);
        buffer.put(geometryData);
        buffer.flip();

        //generate an ID for our geometry buffer in the video memory and make it the active one
        m_geometryBuffer = mGL.createIntBuffer(1);
        mGL.glGenBuffers(m_geometryBuffer);
        mGL.glBindBuffer(OpenGl.GL_ARRAY_BUFFER, m_geometryBuffer.get(0));

        //send the data to the video memory
        mGL.glBufferData(OpenGl.GL_ARRAY_BUFFER, buffer, OpenGl.GL_STATIC_DRAW);


        //create a color buffer, to make our triangle look pretty
        float[] colorData = {
            //3 floats define one color value (red, green and blue) with 0 no intensity and 1 full intensity
            //each color triplet is assigned to the vertex at the same position in the buffer, so first color -> first vertex
            1.0f, 0.0f, 0.0f, //first vertex is red
            0.0f, 1.0f, 0.0f, //lower right vertex is green
            0.0f, 0.0f, 1.0f, //top vertex is blue
        };
        buffer = mGL.createFloatBuffer(colorData.length);
        buffer.put(colorData);
        buffer.flip();

        //generate an ID for the color buffer in the video memory and make it the active one
        m_colorBuffer = mGL.createIntBuffer(1);
        mGL.glGenBuffers(m_colorBuffer);
        mGL.glBindBuffer(OpenGl.GL_ARRAY_BUFFER, m_colorBuffer.get(0));

        //send the data to the video memory
        mGL.glBufferData(OpenGl.GL_ARRAY_BUFFER, buffer, OpenGl.GL_STATIC_DRAW);

        //---------------------------------------------------
        //load our shaders
        try {
            m_vertShader = (LwjglGlslShader)C.getResources().load("shaders/shader.vert", LwjglGlslShader.class).getObject();
            m_fragShader = (LwjglGlslShader)C.getResources().load("shaders/shader.frag", LwjglGlslShader.class).getObject();
        } catch(Exception fml) {
            Log.wtf(TAG, "Failed loading shaders", fml);
        }


        m_program = new LwjglGlslProgram();
        m_program.addShader(m_vertShader);
        m_program.addShader(m_fragShader);
        if (!m_program.link()) {
            throw new RuntimeException("couldn't compile m_program: "+m_program.getInfoLog());
        }
        if (!m_program.validate()) {
            throw new RuntimeException("couldn't validate m_program: "+m_program.getInfoLog());
        }

        //tell OpenGL to use this shader for all coming rendering
        mGL.glUseProgram(m_program.getProgram());

        //get the attachment points for the attributes position and color
        m_positionLocation = mGL.glGetAttribLocation(m_program.getProgram(), "position");
        m_colorLocation = mGL.glGetAttribLocation(m_program.getProgram(), "color");

        //check that the locations are valid, negative value means invalid
        if(m_positionLocation < 0 || m_colorLocation < 0) {
            Log.w(TAG, "Could not query attribute locations");
        }

        //enable these attributes
        mGL.glEnableVertexAttribArray(m_positionLocation);
        mGL.glEnableVertexAttribArray(m_colorLocation);

    }

    private void debuggy_draw() { // place to test shit
        //clear the color buffer
        // mGL.glClear(OpenGl.GL_COLOR_BUFFER_BIT);

        //bind the geometry VBO
        mGL.glBindBuffer(OpenGl.GL_ARRAY_BUFFER, m_geometryBuffer.get(0));
        //point the position attribute to this buffer, being tuples of 4 floats for each vertex
        mGL.glVertexAttribPointer(m_positionLocation, 4 , mGL.GL_FLOAT, false, 0, 0);

        //bint the color VBO
        mGL.glBindBuffer(OpenGl.GL_ARRAY_BUFFER, m_colorBuffer.get(0));
        //this attribute is only 3 floats per vertex
        mGL.glVertexAttribPointer(m_colorLocation, 3 , mGL.GL_FLOAT, false, 0, 0);

        //initiate the drawing process, we want a triangle, start at index 0 and draw 3 vertices
        mGL.glDrawArrays(mGL.GL_TRIANGLES, 0, 3);
    }


This is from the LWJGL wiki entry on VBO's

	Generating a VBO id and buffering

	It is relatively easy to generate a VBO id, much like a Texture id:

		public static int createVBOID() {
			if (GLContext.getCapabilities().GL_ARB_vertex_buffer_object) {
				IntBuffer buffer = BufferUtils.createIntBuffer(1);
				ARBVertexBufferObject.glGenBuffersARB(buffer);
				return buffer.get(0);
			}
			return 0;
		}

	That ID is important, your going to need it when rendering (again, much like a texture id). To buffer the data to VRAM (or whatever your driver feels approperiate), you do this:

	public static void bufferData(int id, FloatBuffer buffer) {
		if (GLContext.getCapabilities().GL_ARB_vertex_buffer_object) {
			ARBVertexBufferObject.glBindBufferARB(ARBVertexBufferObject.GL_ARRAY_BUFFER_ARB, id);
			ARBVertexBufferObject.glBufferDataARB(ARBVertexBufferObject.GL_ARRAY_BUFFER_ARB, buffer, ARBVertexBufferObject.GL_STATIC_DRAW_ARB);
		}
	}

	public static void bufferElementData(int id, IntBuffer buffer) {
		if (GLContext.getCapabilities().GL_ARB_vertex_buffer_object) {
			ARBVertexBufferObject.glBindBufferARB(ARBVertexBufferObject.GL_ELEMENT_ARRAY_BUFFER_ARB, id);
			ARBVertexBufferObject.glBufferDataARB(ARBVertexBufferObject.GL_ELEMENT_ARRAY_BUFFER_ARB, buffer, ARBVertexBufferObject.GL_STATIC_DRAW_ARB);
		}
	}

	There are two GLEnums that are new up there, GL_ARRAY_BUFFER_ARB and GL_STATIC_DRAW_ARB. The first is a buffer type to store vertex information, normals, colours and texture coordinates. There is another type which stores indices and thats GL_ELEMENT_ARRAY_BUFFER_ARB, use both to get the optimum speed from VBOs. Also, consider making your data interleaved and using the strides and offsets to get maximum VBO speed as interleaved data only needs 1 VBO id and thus can be managed easier by the GL driver.

	The second GLEnum: GL_STATIC_DRAW_ARB has a couple of other relatives, the important ones are GL_DYNAMIC_DRAW_ARB and GL_STREAM_DRAW_ARB, both of which are outside the scope of this tutorial.

	Rendering

	Now that you have generated and and stored the VBO id, you can render:
	view sourceprint?
	public static void render() {
		GL11.glEnableClientState(GL11.GL_VERTEX_ARRAY);
		ARBVertexBufferObject.glBindBufferARB(ARBVertexBufferObject.GL_ARRAY_BUFFER_ARB, vertexBufferID);
		GL11.glVertexPointer(3, GL11.GL_FLOAT, 0, 0);
	 
		GL11.glEnableClientState(GL11.GL_COLOR_ARRAY);
		ARBVertexBufferObject.glBindBufferARB(ARBVertexBufferObject.GL_ARRAY_BUFFER_ARB, colourBufferID);
		GL11.glColorPointer(4, GL11.GL_FLOAT, 0, 0);
	 
		ARBVertexBufferObject.glBindBufferARB(ARBVertexBufferObject.GL_ELEMENT_ARRAY_BUFFER_ARB, indexBufferID);
		GL12.glDrawRangeElements(GL11.GL_TRIANGLES, 0, maxIndex, indexBufferSize,
		GL11.GL_UNSIGNED_INT, 0);
	}
